import ipaddress
import json
import os
import subprocess
from pathlib import Path

from flask import Flask, redirect, render_template, request, url_for


app = Flask(__name__)

STATE_FILE = Path(os.getenv("STATE_FILE", "/data/config.json"))
DNSMASQ_CONF = Path(os.getenv("DNSMASQ_CONF", "/data/dnsmasq.conf"))
LEASE_FILE = Path("/data/dnsmasq.leases")
OPTIONS_FILE = Path("/data/options.json")
DNSMASQ_CONTROL = "/usr/local/bin/dnsmasq-control"
DHCP_INTERFACE = os.getenv("DHCP_INTERFACE", "eth0")

DEFAULT_CONFIG = {
    "subnet_cidr": "192.168.1.0/24",
    "range_start": "192.168.1.100",
    "range_end": "192.168.1.200",
    "lease_time": "12h",
    "router": "192.168.1.1",
    "dns_servers": "1.1.1.1,8.8.8.8",
    "domain_name": "lan",
    "ntp_server": "",
    "additional_options": "",
    "static_leases": "",
}


def load_config():
    if not STATE_FILE.exists():
        return DEFAULT_CONFIG.copy()
    try:
        config = json.loads(STATE_FILE.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, OSError):
        return DEFAULT_CONFIG.copy()
    merged = DEFAULT_CONFIG.copy()
    merged.update(config)
    return merged


def save_config(config):
    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
    STATE_FILE.write_text(json.dumps(config, indent=2) + "\n", encoding="utf-8")


def parse_dns_servers(raw_value):
    servers = [item.strip() for item in raw_value.split(",") if item.strip()]
    for server in servers:
        ipaddress.ip_address(server)
    return servers


def parse_static_leases(raw_value):
    leases = []
    if not raw_value.strip():
        return leases
    lines = [line.strip() for line in raw_value.splitlines() if line.strip()]
    for idx, line in enumerate(lines, start=1):
        parts = [p.strip() for p in line.split(",")]
        if len(parts) < 2 or len(parts) > 3:
            raise ValueError(f"Static Lease Zeile {idx} hat ein ungueltiges Format.")
        mac = parts[0]
        ip = parts[1]
        hostname = parts[2] if len(parts) == 3 else ""
        ipaddress.ip_address(ip)
        leases.append((mac, ip, hostname))
    return leases


def validate_config(config):
    errors = []
    try:
        subnet = ipaddress.ip_network(config["subnet_cidr"], strict=False)
    except ValueError:
        errors.append("Subnetz ist ungueltig (CIDR erwartet, z. B. 192.168.1.0/24).")
        subnet = None

    try:
        start_ip = ipaddress.ip_address(config["range_start"])
        end_ip = ipaddress.ip_address(config["range_end"])
        if int(start_ip) > int(end_ip):
            errors.append("DHCP-Bereich: Start-IP muss kleiner oder gleich End-IP sein.")
    except ValueError:
        errors.append("DHCP-Bereich enthaelt ungueltige IP-Adressen.")
        start_ip = None
        end_ip = None

    if subnet and start_ip and start_ip not in subnet:
        errors.append("Range Start liegt nicht im Subnetz.")
    if subnet and end_ip and end_ip not in subnet:
        errors.append("Range Ende liegt nicht im Subnetz.")

    if config["router"].strip():
        try:
            router_ip = ipaddress.ip_address(config["router"].strip())
            if subnet and router_ip not in subnet:
                errors.append("Router-IP liegt nicht im Subnetz.")
        except ValueError:
            errors.append("Router-IP ist ungueltig.")

    if config["ntp_server"].strip():
        try:
            ipaddress.ip_address(config["ntp_server"].strip())
        except ValueError:
            errors.append("NTP-Server muss eine gueltige IP sein.")

    try:
        parse_dns_servers(config["dns_servers"])
    except ValueError:
        errors.append("DNS-Server Liste enthaelt ungueltige IP-Adressen.")

    try:
        parse_static_leases(config["static_leases"])
    except ValueError as err:
        errors.append(str(err))

    if not config["lease_time"].strip():
        errors.append("Lease-Zeit darf nicht leer sein (z. B. 12h).")

    return errors


def render_dnsmasq_config(config):
    dns_servers = parse_dns_servers(config["dns_servers"])
    static_leases = parse_static_leases(config["static_leases"])

    lines = [
        "# Auto-generated by DHCP Server Manager",
        "port=0",
        "log-dhcp",
        f"interface={DHCP_INTERFACE}",
        "except-interface=lo",
        "bind-interfaces",
        f"dhcp-range={config['range_start']},{config['range_end']},{config['lease_time']}",
    ]

    if config["router"].strip():
        lines.append(f"dhcp-option=option:router,{config['router'].strip()}")
    if dns_servers:
        lines.append(f"dhcp-option=option:dns-server,{','.join(dns_servers)}")
    if config["domain_name"].strip():
        lines.append(f"dhcp-option=option:domain-name,{config['domain_name'].strip()}")
    if config["ntp_server"].strip():
        lines.append(f"dhcp-option=option:ntp-server,{config['ntp_server'].strip()}")

    for raw_line in config["additional_options"].splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if line.startswith("dhcp-option="):
            lines.append(line)
        else:
            lines.append(f"dhcp-option={line}")

    for mac, ip, hostname in static_leases:
        if hostname:
            lines.append(f"dhcp-host={mac},{ip},{hostname}")
        else:
            lines.append(f"dhcp-host={mac},{ip}")

    return "\n".join(lines) + "\n"


def test_dnsmasq_conf(conf_path: Path):
    proc = subprocess.run(
        ["dnsmasq", "--test", f"--conf-file={conf_path}"],
        capture_output=True,
        text=True,
        check=False,
    )
    return proc.returncode == 0, (proc.stdout + proc.stderr).strip()


def apply_dnsmasq_config(rendered_conf):
    temp_conf = DNSMASQ_CONF.with_suffix(".candidate")
    backup_conf = DNSMASQ_CONF.with_suffix(".backup")

    temp_conf.write_text(rendered_conf, encoding="utf-8")
    valid, output = test_dnsmasq_conf(temp_conf)
    if not valid:
        temp_conf.unlink(missing_ok=True)
        return False, f"Konfiguration ungueltig: {output}"

    if DNSMASQ_CONF.exists():
        DNSMASQ_CONF.replace(backup_conf)
    temp_conf.replace(DNSMASQ_CONF)

    restart = subprocess.run(
        [DNSMASQ_CONTROL, "restart"],
        capture_output=True,
        text=True,
        check=False,
    )
    if restart.returncode != 0:
        if backup_conf.exists():
            backup_conf.replace(DNSMASQ_CONF)
            subprocess.run([DNSMASQ_CONTROL, "restart"], capture_output=True, text=True, check=False)
        return False, f"dnsmasq Neustart fehlgeschlagen: {(restart.stdout + restart.stderr).strip()}"

    backup_conf.unlink(missing_ok=True)
    return True, "Konfiguration gespeichert und dnsmasq neu gestartet."


def current_status():
    proc = subprocess.run([DNSMASQ_CONTROL, "status"], capture_output=True, text=True, check=False)
    if proc.returncode == 0:
        return proc.stdout.strip()
    return "unknown"


def read_leases():
    leases = []
    if not LEASE_FILE.exists():
        return leases

    for line in LEASE_FILE.read_text(encoding="utf-8", errors="ignore").splitlines():
        raw = line.strip()
        if not raw:
            continue
        # dnsmasq lease format:
        # <expiry_epoch> <mac> <ip> <hostname> <clientid>
        parts = raw.split()
        if len(parts) < 5:
            continue
        expiry_epoch, mac, ip, hostname, clientid = parts[:5]
        hostname = "" if hostname == "*" else hostname
        clientid = "" if clientid == "*" else clientid
        leases.append(
            {
                "expiry_epoch": expiry_epoch,
                "mac": mac,
                "ip": ip,
                "hostname": hostname,
                "clientid": clientid,
            }
        )
    return leases


@app.route("/", methods=["GET"])
def index():
    message = request.args.get("message", "")
    error = request.args.get("error", "")
    config = load_config()
    ingress_path = request.headers.get("X-Ingress-Path", "")
    return render_template(
        "index.html",
        config=config,
        message=message,
        error=error,
        status=current_status(),
        ingress_path=ingress_path,
    )


@app.route("/leases", methods=["GET"])
def leases():
    ingress_path = request.headers.get("X-Ingress-Path", "")
    return render_template(
        "leases.html",
        leases=read_leases(),
        status=current_status(),
        ingress_path=ingress_path,
    )


@app.route("/apply", methods=["POST"])
def apply():
    config = {
        "subnet_cidr": request.form.get("subnet_cidr", "").strip(),
        "range_start": request.form.get("range_start", "").strip(),
        "range_end": request.form.get("range_end", "").strip(),
        "lease_time": request.form.get("lease_time", "").strip(),
        "router": request.form.get("router", "").strip(),
        "dns_servers": request.form.get("dns_servers", "").strip(),
        "domain_name": request.form.get("domain_name", "").strip(),
        "ntp_server": request.form.get("ntp_server", "").strip(),
        "additional_options": request.form.get("additional_options", "").strip(),
        "static_leases": request.form.get("static_leases", "").strip(),
    }

    errors = validate_config(config)
    if errors:
        return render_template(
            "index.html",
            config=config,
            message="",
            error=" | ".join(errors),
            status=current_status(),
            ingress_path=request.headers.get("X-Ingress-Path", ""),
        )

    rendered = render_dnsmasq_config(config)
    ok, output = apply_dnsmasq_config(rendered)
    if not ok:
        return render_template(
            "index.html",
            config=config,
            message="",
            error=output,
            status=current_status(),
            ingress_path=request.headers.get("X-Ingress-Path", ""),
        )

    save_config(config)
    return redirect(url_for("index", message=output))


@app.route("/reload", methods=["POST"])
def reload_service():
    proc = subprocess.run([DNSMASQ_CONTROL, "restart"], capture_output=True, text=True, check=False)
    if proc.returncode != 0:
        return redirect(url_for("index", error=(proc.stdout + proc.stderr).strip()))
    return redirect(url_for("index", message="dnsmasq wurde neu gestartet."))


@app.route("/health", methods=["GET"])
def health():
    return {"status": "ok", "dnsmasq": current_status()}


if __name__ == "__main__":
    port = int(os.getenv("WEB_PORT", "18123"))
    app.run(host="0.0.0.0", port=port)
